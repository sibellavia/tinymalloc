        -:    0:Source:tinymalloc.c
        -:    0:Graph:tinymalloc.gcno
        -:    0:Data:tinymalloc.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * tinymalloc - A simple memory allocator
        -:    3: * Copyright (C) 2023 @sibellavia
        -:    4: *
        -:    5: * This program is free software: you can redistribute it and/or modify
        -:    6: * it under the terms of the GNU General Public License as published by
        -:    7: * the Free Software Foundation, either version 3 of the License, or
        -:    8: * (at your option) any later version.
        -:    9: *
        -:   10: * This program is distributed in the hope that it will be useful,
        -:   11: * but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13: * GNU General Public License for more details.
        -:   14: *
        -:   15: * You should have received a copy of the GNU General Public License
        -:   16: * along with this program.  If not, see <https://www.gnu.org/licenses/>.
        -:   17: *
        -:   18: */
        -:   19:
        -:   20:#include "tinymalloc.h"
        -:   21:#include <errno.h>
        -:   22:#include <pthread.h>
        -:   23:#include <stdbool.h>
        -:   24:#include <stddef.h>
        -:   25:#include <stdint.h>
        -:   26:#include <stdio.h>
        -:   27:#include <string.h>
        -:   28:#include <sys/mman.h>
        -:   29:#include <unistd.h>
        -:   30:
        -:   31:#ifdef DEBUG
        -:   32:#define DEBUG_PRINT(...) printf(__VA_ARGS__)
        -:   33:#else
        -:   34:#define DEBUG_PRINT(...)
        -:   35:#endif
        -:   36:
        -:   37:// basic constants
        -:   38:#define HEAP_SIZE 1048576 // 1 mb
        -:   39:#define BLOCK_SIZE 16     // 16 bytes per block
        -:   40:
        -:   41:// derived constants
        -:   42:#define BITMAP_SIZE (HEAP_SIZE / BLOCK_SIZE / 64)     // size of bitmap in bytes
        -:   43:#define SMALL_ALLOCATION_THRESHOLD (4 * BLOCK_SIZE)   // 64 bytes
        -:   44:#define LARGE_ALLOCATION_THRESHOLD (256 * BLOCK_SIZE) // 4096 bytes
        -:   45:
        -:   46:// compile-time assertions
        -:   47:_Static_assert(HEAP_SIZE % BLOCK_SIZE == 0,
        -:   48:               "HEAP_SIZE must be a multiple of BLOCK_SIZE");
        -:   49:_Static_assert(BITMAP_SIZE > 0, "BITMAP_SIZE must be greater than 0");
        -:   50:
        -:   51:/* Bitmap */
        -:   52:// uint8_t *heap: this is a pointer to the beginning of the memory heap
        -:   53:// uint64_t *bitmap: this is a pointer to the bitmap used to track which blocks
        -:   54:// in the heap are allocated or free
        -:   55:// size_t heap_size: stores the total size of the heap in bytes
        -:   56:// size_t bitmap_size: stores the size of the bitmap
        -:   57:// why i keep track of the sizes separately? bcos the bitmap size is not
        -:   58:// necessarily directly proportional to the heap size due to the use of 64-bit
        -:   59:// integers for efficiency
        -:   60:// many thanks to @basit_ayantunde for suggesting me the change from uint8_t to
        -:   61:// uint64_t for the bitmap
        -:   62:typedef struct {
        -:   63:  uint8_t *heap;
        -:   64:  uint64_t *bitmap;
        -:   65:  size_t heap_size;
        -:   66:  size_t bitmap_size;
        -:   67:} BitmapAllocator;
        -:   68:
        -:   69:static BitmapAllocator allocator;
        -:   70:static bool allocator_initialized = false;
        -:   71:pthread_mutex_t malloc_mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   72:
        -:   73:/* init_allocator() */
        -:   74:// here mmap is used to allocate a large chunk of memory for the heap
        -:   75:// after the check, mmset is used to initialize our bitmap to all zeros
        2:   76:static bool init_allocator() {
        -:   77:  // allocate memory from the heap
        2:   78:  allocator.heap_size = HEAP_SIZE;
        2:   79:  allocator.heap = mmap(NULL, allocator.heap_size, PROT_READ | PROT_WRITE,
        -:   80:                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        2:   81:  if (allocator.heap == MAP_FAILED) {
    #####:   82:    return false; // initialization failed
        -:   83:  }
        -:   84:
        -:   85:  // initialize the bitmap (all blocks are free)
        2:   86:  allocator.bitmap_size = (allocator.heap_size / BLOCK_SIZE + 63) / 64;
        2:   87:  allocator.bitmap =
        2:   88:      mmap(NULL, allocator.bitmap_size * sizeof(uint64_t),
        -:   89:           PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        2:   90:  if (allocator.bitmap == MAP_FAILED) {
    #####:   91:    munmap(allocator.heap, allocator.heap_size);
    #####:   92:    return false; // initialization failed
        -:   93:  }
        -:   94:
        -:   95:  // initialize bitmap to zero (all blocks are free)
        2:   96:  memset(allocator.bitmap, 0, allocator.bitmap_size);
        -:   97:
        2:   98:  return true; // initialization succeeded
        2:   99:}
        -:  100:
        -:  101:/* set_bit(size_t index) */
        -:  102:// sets a specific bit to 1 (marking a block as used)
134406452:  103:static inline void set_bit(size_t index) {
134406452:  104:  size_t bitmap_index = index / 64;
134406452:  105:  size_t bit_offset = index % 64;
134406452:  106:  allocator.bitmap[bitmap_index] |= (1ULL << bit_offset);
134406452:  107:}
        -:  108:
        -:  109:/* clear_bit(size_t index) */
        -:  110:// sets a specific bit to 0 (marking a block as free)
134406450:  111:static inline void clear_bit(size_t index) {
134406450:  112:  size_t bitmap_index = index / 64;
134406450:  113:  size_t bit_offset = index % 64;
134406450:  114:  allocator.bitmap[bitmap_index] &= ~(1ULL << bit_offset);
134406450:  115:}
        -:  116:
        -:  117:/* is_bit_set(size_t index) */
        -:  118:// checks if a specific bit is 1 or 0
134406452:  119:static inline bool is_bit_set(size_t index) {
134406452:  120:  size_t bitmap_index = index / 64;
134406452:  121:  size_t bit_offset = index % 64;
134406452:  122:  return (allocator.bitmap[bitmap_index] & (1ULL << bit_offset)) != 0;
        -:  123:}
        -:  124:
        4:  125:static void *extend_heap(size_t size) {
        4:  126:  size_t page_size = sysconf(_SC_PAGESIZE);
        -:  127:  // round up size to a multiple of HEAP_SIZE
        4:  128:  size_t extension_size = ((size + page_size - 1) / page_size) * page_size;
        -:  129:
        -:  130:  // calculate new sizes
        4:  131:  size_t new_heap_size = allocator.heap_size + extension_size;
        4:  132:  size_t new_bitmap_size = (new_heap_size / BLOCK_SIZE + 63) /
        -:  133:                           64; // i round up to nearest 64-bit unit
        -:  134:
        -:  135:  // mmap goes brr
        4:  136:  void *new_memory = mmap(NULL, extension_size, PROT_READ | PROT_WRITE,
        -:  137:                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        4:  138:  if (new_memory == MAP_FAILED) {
    #####:  139:    return false; // request memory from system failed
        -:  140:  }
        -:  141:
        -:  142:  // allocate new heap
        4:  143:  void *new_heap = mmap(NULL, new_heap_size, PROT_READ | PROT_WRITE,
        -:  144:                        MAP_PRIVATE | MAP_ANON, -1, 0);
        4:  145:  if (new_heap == MAP_FAILED) {
    #####:  146:    return NULL;
        -:  147:  }
        -:  148:
        -:  149:  // copy old heap to new location
        4:  150:  memcpy(new_heap, allocator.heap, allocator.heap_size);
        -:  151:
        -:  152:  // allocate new bitmap
        4:  153:  void *new_bitmap =
        4:  154:      mmap(NULL, new_bitmap_size * sizeof(uint64_t), PROT_READ | PROT_WRITE,
        -:  155:           MAP_PRIVATE | MAP_ANON, -1, 0);
        4:  156:  if (new_bitmap == MAP_FAILED) {
    #####:  157:    munmap(new_heap, new_heap_size);
    #####:  158:    return NULL;
        -:  159:  }
        -:  160:
        -:  161:  // copy old bitmap to new location
        4:  162:  memcpy(new_bitmap, allocator.bitmap,
        -:  163:         allocator.bitmap_size * sizeof(uint64_t));
        -:  164:
        -:  165:  // initialize new bitmap area to 0 (all blocks free)
        4:  166:  memset(new_bitmap + allocator.bitmap_size, 0,
        -:  167:         (new_bitmap_size - allocator.bitmap_size) * sizeof(uint64_t));
        -:  168:
        -:  169:  // free old heap and bitmap
        4:  170:  munmap(allocator.heap, allocator.heap_size);
        4:  171:  munmap(allocator.bitmap, allocator.bitmap_size * sizeof(uint64_t));
        -:  172:
        -:  173:  // update allocator structure and finally we return!
        4:  174:  allocator.heap = new_heap;
        4:  175:  allocator.bitmap = new_bitmap;
        4:  176:  allocator.heap_size = new_heap_size;
        4:  177:  allocator.bitmap_size = new_bitmap_size;
        -:  178:
        8:  179:  return (void *)((char *)allocator.heap + allocator.heap_size -
        4:  180:                  extension_size);
        4:  181:}
        -:  182:
     8042:  183:static size_t find_free_blocks(size_t blocks_needed) {
     8816:  184:  for (size_t bitmap_index = 0;
     8816:  185:       bitmap_index < allocator.bitmap_size / sizeof(uint64_t);
      774:  186:       bitmap_index++) {
     8812:  187:    if (allocator.bitmap[bitmap_index] != UINT64_MAX) {
        -:  188:      int first_free_bit;
     8810:  189:      if (blocks_needed <= SMALL_ALLOCATION_THRESHOLD / BLOCK_SIZE ||
     8806:  190:          blocks_needed >= LARGE_ALLOCATION_THRESHOLD / BLOCK_SIZE) {
        -:  191:        // hybrid approach here
        -:  192:        // manual bit scanning for small and large allocations
      782:  193:        uint64_t bitmap_word = ~allocator.bitmap[bitmap_index];
      782:  194:        first_free_bit = __builtin_ctzll(bitmap_word);
      782:  195:      } else {
        -:  196:        // __builtin_ffsll for medium allocations
     8028:  197:        first_free_bit = __builtin_ffsll(~allocator.bitmap[bitmap_index]) - 1;
        -:  198:      }
        -:  199:
     8810:  200:      size_t start_block = bitmap_index * 64 + first_free_bit;
     8810:  201:      size_t end_block = start_block + blocks_needed;
        -:  202:
     8810:  203:      if (end_block <= allocator.heap_size / BLOCK_SIZE) {
     8038:  204:        bool enough_space = true;
134414490:  205:        for (size_t i = start_block; i < end_block; i++) {
134406452:  206:          if (is_bit_set(i)) {
    #####:  207:            enough_space = false;
    #####:  208:            break;
        -:  209:          }
134406452:  210:        }
     8038:  211:        if (enough_space) {
     8038:  212:          return start_block;
        -:  213:        }
    #####:  214:      }
      772:  215:    }
      774:  216:  }
        4:  217:  return SIZE_MAX; // not found :-(
     8042:  218:}
        -:  219:
     8038:  220:static void *allocate_blocks(size_t start_block, size_t blocks_needed,
        -:  221:                             size_t size) {
134414490:  222:  for (size_t i = start_block; i < start_block + blocks_needed; i++) {
134406452:  223:    set_bit(i);
134406452:  224:  }
        -:  225:
     8038:  226:  void *allocated_memory = allocator.heap + (start_block * BLOCK_SIZE);
     8038:  227:  allocated_memory =
     8038:  228:      (void *)(((uintptr_t)allocated_memory + sizeof(size_t) - 1) &
        -:  229:               ~(sizeof(size_t) - 1));
     8038:  230:  *(size_t *)allocated_memory = size;
        -:  231:
     8038:  232:  return (char *)allocated_memory + sizeof(size_t);
        -:  233:}
        -:  234:
        -:  235:/* tinymalloc */
     8008:  236:void *tinymalloc(size_t size) {
     8008:  237:  if (size == 0)
        2:  238:    return NULL;
        -:  239:
     8006:  240:  if (!allocator_initialized) {
        2:  241:    pthread_mutex_lock(&malloc_mutex);
        2:  242:    if (!allocator_initialized) {
        2:  243:      if (!init_allocator()) {
    #####:  244:        pthread_mutex_unlock(&malloc_mutex);
    #####:  245:        return NULL;
        -:  246:      }
        2:  247:      allocator_initialized = true;
        2:  248:    }
        2:  249:    pthread_mutex_unlock(&malloc_mutex);
        2:  250:  }
        -:  251:
     8006:  252:  pthread_mutex_lock(&malloc_mutex);
        -:  253:
     8006:  254:  size_t total_size = size + sizeof(size_t);
     8006:  255:  size_t blocks_needed = (total_size + BLOCK_SIZE - 1) / BLOCK_SIZE;
        -:  256:
        -:  257:  DEBUG_PRINT("Allocating %zu bytes (%zu blocks)\n", size, blocks_needed);
        -:  258:
     8006:  259:  size_t start_block = find_free_blocks(blocks_needed);
        -:  260:
     8006:  261:  if (start_block == SIZE_MAX) {
        -:  262:    // couldn't find space, i try to extend heap
        4:  263:    size_t extension_size =
        4:  264:        (blocks_needed * BLOCK_SIZE > allocator.heap_size / 4)
        4:  265:            ? (blocks_needed * BLOCK_SIZE)
    #####:  266:            : (allocator.heap_size / 4);
        4:  267:    if (extend_heap(extension_size) == NULL) {
    #####:  268:      pthread_mutex_unlock(&malloc_mutex);
    #####:  269:      return NULL;
        -:  270:    }
        -:  271:
        -:  272:    // try allocation again...
        4:  273:    start_block = find_free_blocks(blocks_needed);
        4:  274:    if (start_block == SIZE_MAX) {
    #####:  275:      pthread_mutex_unlock(&malloc_mutex);
    #####:  276:      return NULL;
        -:  277:    }
        4:  278:  }
        -:  279:
     8006:  280:  void *result = allocate_blocks(start_block, blocks_needed, size);
        -:  281:
     8006:  282:  pthread_mutex_unlock(&malloc_mutex);
     8006:  283:  return result;
     8008:  284:}
        -:  285:
        -:  286:/* tinyfree */
     7988:  287:void tinyfree(void *ptr) {
     7988:  288:  if (ptr == NULL)
        2:  289:    return;
        -:  290:
     7986:  291:  pthread_mutex_lock(&malloc_mutex);
        -:  292:
        -:  293:  // calculate which block this pointer corrisponds to
     7986:  294:  void *actual_start = (char *)ptr - sizeof(size_t);
        -:  295:
     7986:  296:  if ((uintptr_t)actual_start < (uintptr_t)allocator.heap ||
    16072:  297:      (uintptr_t)actual_start >=
     8036:  298:          (uintptr_t)(allocator.heap + allocator.heap_size)) {
       50:  299:    pthread_mutex_unlock(&malloc_mutex);
       50:  300:    return;
        -:  301:  }
        -:  302:
        -:  303:  // retrieve the size of the allocation
     8036:  304:  size_t size = *(size_t *)actual_start;
        -:  305:
        -:  306:  // calculate which block this pointer corresponds to
     8036:  307:  size_t block_index = ((uint8_t *)actual_start - allocator.heap) / BLOCK_SIZE;
        -:  308:
        -:  309:  // calculate how many blocks were allocated
     8036:  310:  size_t blocks_to_free = (size + sizeof(size_t) + BLOCK_SIZE - 1) / BLOCK_SIZE;
        -:  311:
     8036:  312:  if (block_index + blocks_to_free > allocator.heap_size / BLOCK_SIZE) {
    #####:  313:    pthread_mutex_unlock(&malloc_mutex);
    #####:  314:    return;
        -:  315:  }
        -:  316:
        -:  317:  DEBUG_PRINT("freeing memory at %p, size: %zu, block index: %zu, blocks to "
        -:  318:              "free: %zu\n",
        -:  319:              ptr, size, block_index, blocks_to_free);
        -:  320:
        -:  321:  // mark the blocks as free
134414486:  322:  for (size_t i = block_index; i < block_index + blocks_to_free; i++) {
134406450:  323:    clear_bit(i);
        -:  324:    DEBUG_PRINT("cleared bit at index %zu\n", i);
134406450:  325:  }
        -:  326:
     8036:  327:  pthread_mutex_unlock(&malloc_mutex);
     8088:  328:}
